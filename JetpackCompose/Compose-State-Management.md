### Overviews:
This markdown is aiming towards Use and Management of State in Jetpack Compose Application.

### Events in Compose:
Any action that causes the modification of state is called an `event`. Events are inputs generated from outside or inside an application, such as button-press, sensors sending a new value, or network responses. 
Events notify a part of a program that something has happened, resulting in changes to the UI.

* Event - An event is generated by the user or another part of the program.
* Update State - An event handler changes the state that is used by the UI.
* Display State - The UI is updated to display the new state.

### Recomposition of Compose Composition:
When a state changes, Compose re-executes the affected composable functions with the new state, creating an updated UI—this is called recomposition. Compose also looks at what data an individual composable needs, so that it only recomposes components whose data has changed and skips those that are not affected.

* The Composition: a description of the UI built by Jetpack Compose when it executes composables.

* Initial composition: creation of a Composition by running composables the first time.

* Recomposition: re-running composables to update the Composition when data changes

To be able to do this `Recompose`, Compose needs to know what state to track, so that when it receives an update it can schedule the recomposition.

### Compose State:
Compose has a special state tracking system in place that schedules recompositions for any composables that read a particular state. This lets Compose be granular and just recompose those composable functions that need to change, not the whole UI. This is done by tracking not only "writes" (that is, state changes), but also "reads" to the state.

Use Compose's `State` and `MutableState` types to make state observable by Compose.

* Fn `remember` : is used to preserve this value across recompositions. A value calculated by `remember` function is stored in the Composition during the initial composition, and the stored value is kept across recompositions.

Usually remember and mutableStateOf are used together in composable functions.

```kotlin
val count: MutableState<Int> = remember { mutableStateOf(0) } 
// mod it by count.value = new_val
// get it by count.value

// or
val count: MutableState<Int> by remember { mutableStateOf(0) } 
// mod it by count = new_val
// get it by count
```

### Compose State with Other Observable:
using other observable types like LiveData, StateFlow, Flow, and RxJava's Observable to store state in an app. To allow Compose to use this state and automatically recompose when the state changes you need to map these to a State<T>.

* Key Point -> Flow(`emit/collect`) and Livedata(`initialize/observe`)

Docs : https://developer.android.com/jetpack/compose/libraries
### State persistence by rememberSaveable:
`rememberSaveable` automatically saves any value that can be saved in a Bundle (A mapping from String keys to various Parcelable values). For other values, you can pass in a custom saver object using (https://developer.android.com/jetpack/compose/state#restore-ui-state)

### State Hoisting:
The pattern where the state goes down, and events go up is called Unidirectional Data Flow (UDF), and state hoisting is how android implement this architecture in Compose.

Mechanism:

* Single source of truth: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.
* Shareable: Hoisted state can be shared with multiple composables.
* Interceptable: Callers to the stateless composables can decide to ignore or modify events before changing the state.
* Decoupled: The state for a stateless composable function can be stored anywhere. For example, in a ViewModel.

Note: A Composable can be `StateFull` or `StateLess`. By State Hoisting, a state (in a Compose Fn) is lifted upward to it's parent, making that stateless, and the state is passed using callback lambda from it's parent/caller. 

### LazyColumn and rememberLazyListState:
```kotlin
@Composable
fun LazyColumn(
// ...
    state: LazyListState = rememberLazyListState(),
// ...
)
```

The composable function rememberLazyListState creates an initial state for the list using rememberSaveable. When the Activity is recreated, the scroll state is maintained without you having to code anything.

Docs : https://developer.android.com/jetpack/compose/lists#react-to-scroll-position

### Observable MutableList (Management State With List Data) :
From and Initial List : The extension function `toMutableStateList()` is the way to create an observable MutableList from an initial mutable or immutable Collection, such as List.
```kotlin
val listNum = listOf(1,2,3,4)
val list = remember { listNum.toMutableStateList() }
```

From Empty List : the factory method `mutableStateListOf` can be used to create the observable MutableList and then the elements can be added to the initial state.
```kotlin
// don't
val listNum = listOf(1,2,3,4)
val list = remember { mutableStateListOf<WellnessTask>().apply { addAll(listNum) } }
// list.addAll(listNum) will add duplicate item on every recomposition, so no addAll operation os state directly
```

Note : The `mutableStateOf` function returns an object of type MutableState<T>, `mutableStateListOf` and `toMutableStateList` functions return an object of type SnapshotStateList<T>

Note : rememberSaveable with List<CustomType> will not work, need to provide custom saver (@Parcelize bundle). https://developer.android.com/jetpack/compose/state#restore-ui-state


Docs for saving ui state : https://developer.android.com/topic/libraries/architecture/saving-states#onsaveinstancestate
### Compose state and ViewModels
ViewModels provide the UI state and access to the business logic located in other layers of the app. ViewModels survive configuration changes, so they have a longer lifetime than the Composition (Composable/Views).
* So in Compose (With viewModel) there is no need to use `remember` fn.

```kotlin
class WellnessViewModel : ViewModel() {
    private val _tasks = getWellnessTasks().toMutableStateList()
    val tasks: List<WellnessTask>
        get() = _tasks


   fun remove(item: WellnessTask) {
       _tasks.remove(item)
   }
}

private fun getWellnessTasks() = List(30) { i -> WellnessTask(i, "Task # $i") }

/////////////////////////////////// Compose/View /////////////////////

@Composable
fun WellnessScreen(modifier: Modifier = Modifier, wellnessViewModel: WellnessViewModel = viewModel()) {

    WellnessTasksList(
        list = wellnessViewModel.tasks,
        onCloseTask = { task -> wellnessViewModel.remove(task) })

}
```

Note: To track any changes on data, it needs to be defined as `MutableState<T>`. Or sometime (for modification) removing the value and reassigning can force Compose to track the item, but this is an expensive task.

### Demystifying `remember`, `mutableStateOf` and `derivedStateOf`
- `remember` -> usually when a function re-renders, the local variables go back to it's initial state. But in Composable function, `remember` block stores the last calculated/updated value and provide that on re-render/re-compose.

* Note: `remember` is like `lazy` in non-compose world. As docs stated `The first call to lazy's get() executes the lambda passed to lazy() and remembers the result. Subsequent calls to get() simply return the remembered result.`

- `mutableStateOf` (re-composition trigger) -> The function returns a MutableState object which leads to a recomposition in case its value changes and the value is read.

    - If the value is the same, nothing happens.
    - If the value isn’t read by anyone, nothing happens.
    - If the value changes, all composables that read this value will be recomposed.

`derivedStateOf` -> as the name, it triggers state change only if the `condition` meet based on another state. This is derived from another state.


Guides: https://stefma.medium.com/jetpack-compose-remember-mutablestateof-derivedstateof-and-remembersaveable-explained-270dbaa61b8