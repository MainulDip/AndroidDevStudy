### Overviews:
This markdown is aiming towards Use and Management of State in Jetpack Compose Application.

### Events in Compose:
Any action that causes the modification of state is called an `event`. Events are inputs generated from outside or inside an application, such as button-press, sensors sending a new value, or network responses. 
Events notify a part of a program that something has happened, resulting in changes to the UI.

* Event - An event is generated by the user or another part of the program.
* Update State - An event handler changes the state that is used by the UI.
* Display State - The UI is updated to display the new state.

### Recomposition of Compose Composition:
When a state changes, Compose re-executes the affected composable functions with the new state, creating an updated UIâ€”this is called recomposition. Compose also looks at what data an individual composable needs, so that it only recomposes components whose data has changed and skips those that are not affected.

* The Composition: a description of the UI built by Jetpack Compose when it executes composables.

* Initial composition: creation of a Composition by running composables the first time.

* Recomposition: re-running composables to update the Composition when data changes.

To be able to do this `Recompose`, Compose needs to know what state to track, so that when it receives an update it can schedule the recomposition.

### Compose State:
Compose has a special state tracking system in place that schedules recompositions for any composables that read a particular state. This lets Compose be granular and just recompose those composable functions that need to change, not the whole UI. This is done by tracking not only "writes" (that is, state changes), but also "reads" to the state.

Use Compose's `State` and `MutableState` types to make state observable by Compose.

* Fn `remember` : is used to preserve this value across recompositions. A value calculated by `remember` function is stored in the Composition during the initial composition, and the stored value is kept across recompositions.

Usually remember and mutableStateOf are used together in composable functions.

```kotlin
val count: MutableState<Int> = remember { mutableStateOf(0) } 
// mod it by count.value = new_val
// get it by count.value

// or
val count: MutableState<Int> by remember { mutableStateOf(0) } 
// mod it by count = new_val
// get it by count
```

### Compose State with Other Observable:
using other observable types like LiveData, StateFlow, Flow, and RxJava's Observable to store state in an app. To allow Compose to use this state and automatically recompose when the state changes you need to map these to a State<T>.

Docs : https://developer.android.com/jetpack/compose/libraries
### State persistence by rememberSaveable:
`rememberSaveable` automatically saves any value that can be saved in a Bundle (A mapping from String keys to various Parcelable values). For other values, you can pass in a custom saver object using (https://developer.android.com/jetpack/compose/state#restore-ui-state)

### State Hoisting:
The pattern where the state goes down, and events go up is called Unidirectional Data Flow (UDF), and state hoisting is how android implement this architecture in Compose.

Mechanism:

* Single source of truth: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.
* Shareable: Hoisted state can be shared with multiple composables.
* Interceptable: Callers to the stateless composables can decide to ignore or modify events before changing the state.
* Decoupled: The state for a stateless composable function can be stored anywhere. For example, in a ViewModel.

Note: A Composable can be `StateFull` or `StateLess`. By State Hoisting, a state (in a Compose Fn) is lifted upward to it's parent, making that stateless, and the state is passed using callback lambda from it's parent/caller. 

### LazyColumn and rememberLazyListState:
```kotlin
@Composable
fun LazyColumn(
// ...
    state: LazyListState = rememberLazyListState(),
// ...
)
```

The composable function rememberLazyListState creates an initial state for the list using rememberSaveable. When the Activity is recreated, the scroll state is maintained without you having to code anything.

Docs : https://developer.android.com/jetpack/compose/lists#react-to-scroll-position

### Observable MutableList (Management State With List Data) :
From and Initial List : The extension function `toMutableStateList()` is the way to create an observable MutableList from an initial mutable or immutable Collection, such as List.
```kotlin
val listNum = listOf(1,2,3,4)
val list = remember { listNum.toMutableStateList() }
```

From Empty List : the factory method `mutableStateListOf` can be used to create the observable MutableList and then the elements can be added to the initial state.
```kotlin
// don't
val listNum = listOf(1,2,3,4)
val list = remember { mutableStateListOf<WellnessTask>().apply { addAll(listNum) } }
// list.addAll(listNum) will add duplicate item on every recomposition, so no addAll operation os state directly
```

Note : The `mutableStateOf` function returns an object of type MutableState<T>, `mutableStateListOf` and `toMutableStateList` functions return an object of type SnapshotStateList<T>

Note : rememberSaveable with List<CustomType> will not work, need to provide custom saver (@Parcelize bundle). https://developer.android.com/jetpack/compose/state#restore-ui-state


Docs for saving ui state : https://developer.android.com/topic/libraries/architecture/saving-states#onsaveinstancestate
### Compose state and ViewModels: