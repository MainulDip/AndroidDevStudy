## Overview:
This is part two of the continued android-app-fundamentals. It's the compiled form of https://developer.android.com/courses/android-basics-kotlin/unit-2 and some more.

### Some UI-Elements/Views:
- EditText - for entering and editing text

- TextView - to display text like the service question and tip 
amount
- RadioButton - a selectable radio button for each tip option

- RadioGroup - to group the radio button options, android:checkedButton="@id/option_twenty_percent" checked initially/default

- Switch - an on/off toggle for choosing whether to round up the 
tip or not

The UI for an Android app is built as a containment hierarchy of components (widgets), and the on-screen layouts of those components (Buttons, TextViews, ImageViews). Note those layouts are UI components themselves.


### Terms:
- androidx : Jetpack based UI-Component Library
- xmlns : XML namespace
- @+id/.... : a new resource ID

### Get User Input:

### View binding and findViewById:
Quick access to a view element using findViewById. like
```kotlin
val Button myButton = findViewById(R.id.my_button); // tied with the xlm view elemnt "android:id="@+id/my_button"
```

View Binding makes it much easier and faster to call methods on the views in your UI. You'll need to enable view binding for your app in Gradle, and make some code changes.

Enable View Binding:  pn app's build.gradle
```gradle
buildFeatures {
    viewBinding = true
}
```

MainActivity.kt
```kt
class MainActivity : AppCompatActivity() {

    lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Old way with findViewById()
        val myButton: Button = findViewById(R.id.my_button)
        myButton.text = "A button"

        // Better way with view binding
        val myButton: Button = binding.myButton
        myButton.text = "A button"

        // Best way with view binding and no extra variable
        binding.myButton.text = "A button"
    }
}
```

Note: The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end. Similarly, the reference for each view is generated by removing underscores and converting the view name to camel case. For example, in Pascal case activity_main.xml becomes ActivityMainBinding, and can be accessed using @id/text_view as binding.textView.


### Currency Formatter and XML's String Parameters:
* Currency Formatter: NumberFormat.getCurrencyInstance().format($amount)
* String Parameters: On app > res > values > strings.xml
```xml
<string name="tip_amount">Tip Amount: %s</string>
```
On activity
```kotlin
// set the tipResult
binding.tipResult.text = getString(R.string.tip_amount, formattedTip)
```

* Development Placeholder Text Attribute in activity xml: tools:text="Tip Amount: $7"

### Theming and Colors:
As standered practice with Material UI Design, there can be 12 named color attributes.
* 1st group: Primary, Primary Variand, Secondary, Secondary variant
* 2nd group: Backgroun, Surface, Error
* 3rd group: On Primary, On Secondary, 
* 4th group: On Backgroun, On Surface, On Error

=> Those are mapped into theme xml by camelCase (Not PascalCase, not snake_case) with 'color' prefix like => colorPrimary, colorPrimaryVariant, colorOnPrimary.

* Dark Mode Variant: theme.xml night

### Apps Icon 
From project view app > src > main > res > mipmap-hdpi to mipmap-xxxhdpi, all the app's icons are there.
launcher icon assets are located in mipmap directories separate from other app assets located in drawable directories. This is because some launchers may display your app icon at a larger size than what's provided by the device's default density bucket.
For a medium-density device (mdpi), there are 160 dots per inch on the screen while an extra-extra-extra-high-density device (xxxhdpi) has 640 dots per inch on the screen. that's why the folder structure *hdpi to *xxxhdpi. Android will select the resource at the closest larger density bucket and then scale down for applicable divices
* mdpi - resources for medium-density screens (~160 dpi)
* hdpi - resources for high-density screens (~240 dpi)
* xhdpi - resources for extra-high-density screens (~320 dpi)
* xxhdpi - resources for extra-extra-high-density screens (~480dpi)
* xxxhdpi - resources for extra-extra-extra-high-density screens (~640dpi)
* nodpi - resources that are not meant to be scaled, regardless of the screen's pixel density
* anydpi - resources that scale to any density

### Material Design Components (MDC):
It's recommended to use Material Components whenever possible. By using Material Components, the app will operate in a more consistent way alongside other apps on the user's device. That way the UI patterns learned in one app can be carried over to the next one. Hence users will be able to learn how to use the app much faster intuitively.
```kotlin
// app/build.gradle
dependencies {
    implementation 'com.google.android.material:material:<version>'
}
```

Note: Material 2 to 3 => Theme.MaterialComponents.* become Theme.Material3.* for themes and Widget.MaterialComponents.* become Widget.Material3.* for widget styles.

### Extending Theme or calling other resource files attribute:
Themes defaul value can be changed by defining inside theme file (usually themes.xml). Theme's name is defiened inside resources' style "name" attribute, and usually there will be a parent theme like "<style name="Theme.UITesting" parent="Theme.MaterialComponents.DayNight.DarkActionBar">". The Theme is hooked by the AndroidManifest.xml application attribute's android:theme="@style/Theme.UITesting" entry.

Gradle will enlist all defiend attributes inside res directory, filename can be anything (stick with best practice) but attribute name should be specific like style, dimen, bool, color, etc. When referencing from other xml files, use @attributetype/attribute_unique_name convension. 

Docs : Resources Type https://developer.android.com/guide/topics/resources/more-resources

* Widget : For a specific view type, widget can also be defiend to extend the style at component basis. Widget name should be on "Widget.AppName.ViewName" convension where parent name is "Widget.MaterialComponent.ViewName". Several attributes can be set once for a targeted view and can be reused maintaining DRY principle.

### Activity xml's parent view:
Parent view should define the xml namespaces
```xml
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    .......

</ScrollView>
```


### Hiding Keyboard | using view.setOnFocusChangeListener :
Keyboard can be hide when enter is pressed and when focus is changed. To utilize view.setOnFocusChangeListener, activity's (xml) layout container should be enlist android:clickable="true" and android:focusableInTouchMode="true" (Not inside non-layout container like scrollview). Then use view.setOnFocusChangeListener. To hide keyboar on enter press, its simple
```kotlin
// inside onCreate func
view.apply {
    setOnKeyListener { view, keycode, _ -> handleKeyEvent(view, keycode) }
    setOnFocusChangeListener { view, bool ->
        val inputMethodManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        if (bool) {
            inputMethodManager.showSoftInput(view, 0)
        } else {
            inputMethodManager.hideSoftInputFromWindow(view.windowToken, 0)
        }

        Toast.makeText(this.context, "Focus changed $bool", Toast.LENGTH_SHORT).show()
    }
}

// inside the class
private fun handleKeyEvent(view: View, keyCode: Int): Boolean {
        if (keyCode == KeyEvent.KEYCODE_ENTER) {
            // Hide the keyboard
            val inputMethodManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            inputMethodManager.hideSoftInputFromWindow(view.windowToken, 0)
            return true
        }
        return false
    }
```

### Android Test (Instrumented + Local + etc):
* Instrumented (End-to-End, Integration Tests): tests are usually automated UI tests, launching an app (on emulator or physical devices) and then interacting with it.
* Local Test (Unit, Integration): automated tests those are execute on development machine or a server, so they're also called host-side tests. They're usually small and fast, isolating the subject under test from the rest of the app.
* Not all unit tests are local, and not all end-to-end tests run on a device.
* Unit tests or small tests only verify a very small portion of the app, such as a method or class.
* End-to-end tests or big tests verify larger parts of the app at the same time, such as a whole screen or user flow.
* Medium tests are in between and check the integration between two or more units.

#### Instumented/UI testing example using espresso:

```kotlin
@RunWith(AndroidJUnit4::class)
class CalculatorTests {
    @get:Rule()
    val activity = ActivityScenarioRule(MainActivity::class.java)

    @Test()
    fun calculate_20_percent_tip() {
        onView(withId(R.id.cost_of_service_edit_text))
            .perform(typeText("50.00"))
            .perform(ViewActions.closeSoftKeyboard())

        onView(withId(R.id.calculate_button))
            .perform(click())

        onView(withId(R.id.tip_result))
            .check(ViewAssertions.matches(withText(CoreMatchers.containsString("$10.00"))))
    }
}
```

### Design Pattern Common:
* Adapter: Adapter is a design pattern that adapts the data into something that can be used by RecyclerView. Usually adapter fetch data from a datastore/databases and format the data to feed the ui/recyclerview.

* ViewHolders: RecyclerView doesn't interact directly with item views, but deals with ViewHolders. A ViewHolder represents a single list item view in RecyclerView, and can be reused when possible. A ViewHolder instance holds references to the individual views within a list item layout (hence the name "view holder"). This makes it easier to update the list item view with new data. View holders also add information that RecyclerView uses to efficiently move views around the screen
* LayoutInflater: inflate an XML layout into a hierarchy of view objects. Or simply it converts xml layout file into a view object.

### Layout placeholder text/images:
Use "xmlns:tools="http://schemas.android.com/tools" namespace and assaign text or image using "tools:text="Place Holder Text" or "tools:src="@drawable/placeholderimage"


### App's Gradle Dependencies:
* implementation: is for dependencies that will be used in the application itself 
* testImplementation is for dependencies that are used in unit tests, and 
* androidTestImplementation is for dependencies that are used in instrumentation tests
### Mockito Unit Test Library:
```kotlin
testImplementation 'org.mockito:mockito-core:3.12.4'
```

* unit tests run on the JVM and not on an actual device, so there is no Context. The mock method allows us to create a "mocked" instance of a Context. It doesn't have any real functionality, but it can be used to test methods that require a context.
### Tasks:
* Fragments, proto datastore (https://developer.android.com/codelabs/android-proto-datastore?hl=en#2)
* ViewModel, Observable Data Objects and LiveData, 
* Kotlin Flow..............
* Everyting on -> App Architecture (Android Developers Docs)
* Custom Annotation Java Kotlin