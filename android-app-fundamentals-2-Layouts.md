## Overview:
This is part two of the continued android-app-fundamentals. It's the compiled form of https://developer.android.com/courses/android-basics-kotlin/unit-2 and some more.

### Some UI-Elements/Views:
- EditText - for entering and editing text

- TextView - to display text like the service question and tip 
amount
- RadioButton - a selectable radio button for each tip option

- RadioGroup - to group the radio button options, android:checkedButton="@id/option_twenty_percent" checked initially/default

- Switch - an on/off toggle for choosing whether to round up the 
tip or not

The UI for an Android app is built as a containment hierarchy of components (widgets), and the on-screen layouts of those components (Buttons, TextViews, ImageViews). Note those layouts are UI components themselves.


### Terms:
- androidx : Jetpack based UI-Component Library
- xmlns : XML namespace
- @+id/.... : a new resource ID

### Get User Input:

### View binding and findViewById:
Quick access to a view element using findViewById. like
```kotlin
val Button myButton = findViewById(R.id.my_button); // tied with the xlm view elemnt "android:id="@+id/my_button"
```

View Binding makes it much easier and faster to call methods on the views in your UI. You'll need to enable view binding for your app in Gradle, and make some code changes.

Enable View Binding:  app's build.gradle
```gradle
buildFeatures {
    viewBinding = true
}
```

MainActivity.kt
```kt
class MainActivity : AppCompatActivity() {

    lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Old way with findViewById()
        val myButton: Button = findViewById(R.id.my_button)
        myButton.text = "A button"

        // Better way with view binding
        val myButton: Button = binding.myButton
        myButton.text = "A button"

        // Best way with view binding and no extra variable
        binding.myButton.text = "A button"
    }
}
```

Note: The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end. Similarly, the reference for each view is generated by removing underscores and converting the view name to camel case. For example, in Pascal case activity_main.xml becomes ActivityMainBinding, and can be accessed using @id/text_view as binding.textView.


### Currency Formatter and XML's String Parameters:
* Currency Formatter: NumberFormat.getCurrencyInstance().format($amount)
* String Parameters: On app > res > values > strings.xml
```xml
<string name="tip_amount">Tip Amount: %s</string>
```
On activity
```kotlin
// set the tipResult
binding.tipResult.text = getString(R.string.tip_amount, formattedTip)
```

* Development Placeholder Text Attribute in activity xml: tools:text="Tip Amount: $7"

### Theming and Colors:
As standered practice with Material UI Design, there can be 12 named color attributes.
* 1st group: Primary, Primary Variand, Secondary, Secondary variant
* 2nd group: Backgroun, Surface, Error
* 3rd group: On Primary, On Secondary, 
* 4th group: On Backgroun, On Surface, On Error

=> Those are mapped into theme xml by camelCase (Not PascalCase, not snake_case) with 'color' prefix like => colorPrimary, colorPrimaryVariant, colorOnPrimary.

* Dark Mode Variant: theme.xml night

### Apps Icon 
From project view app > src > main > res > mipmap-hdpi to mipmap-xxxhdpi, all the app's icons are there.
launcher icon assets are located in mipmap directories separate from other app assets located in drawable directories. This is because some launchers may display your app icon at a larger size than what's provided by the device's default density bucket.
For a medium-density device (mdpi), there are 160 dots per inch on the screen while an extra-extra-extra-high-density device (xxxhdpi) has 640 dots per inch on the screen. that's why the folder structure *hdpi to *xxxhdpi. Android will select the resource at the closest larger density bucket and then scale down for applicable divices
* mdpi - resources for medium-density screens (~160 dpi)
* hdpi - resources for high-density screens (~240 dpi)
* xhdpi - resources for extra-high-density screens (~320 dpi)
* xxhdpi - resources for extra-extra-high-density screens (~480dpi)
* xxxhdpi - resources for extra-extra-extra-high-density screens (~640dpi)
* nodpi - resources that are not meant to be scaled, regardless of the screen's pixel density
* anydpi - resources that scale to any density

### Tasks:
* Fragments
* ViewModel, Observable Data Objects and LiveData, 
* Kotlin Flow.......
* Everyting on -> App Architecture (Android Developers Docs)